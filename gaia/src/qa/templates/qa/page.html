{% extends "qa/base.html" %}
{% block title %}item {{item_index.dom_name}}{% endblock %}

{% block head %}
<script src="{{STATIC_URL}}js/jquery-1.9.1.js" type="text/javascript"></script>
<script src="{{STATIC_URL}}js/jquery.tabSlideOut.v1.3.js" type="text/javascript"></script>

<style type="text/css">
.fix_tab {
    padding: 20px;
    width: 550px;
    background: #cde;
    border: #29216d 2px solid;
}
.reject_tab {
    padding: 20px;
    width: 550px;
    background: orange;
    border: #29216d 2px solid;
}
</style>

{% endblock %}
         
{% block javascript %}
function set_tabs() {
   
    $(function(){
        $('.fix_tab').tabSlideOut({
            tabHandle: '.handle1',
            onLoadSlideOut: true,
            pathToTabImage: '{{STATIC_URL}}images/fix_tab.png',
            imageHeight: '122px',
            imageWidth: '40px',
            tabLocation: 'right',
            speed: 0,
            action: 'click',
            topPos: '170px',
            fixedPosition: false,
        });
    });
   
    $(function(){
        $('.reject_tab').tabSlideOut({
            tabHandle: '.handle2',
            pathToTabImage: '{{STATIC_URL}}images/reject_tab.png',
            imageHeight: '122px',
            imageWidth: '40px',
            tabLocation: 'right',
            speed: 0,
            action: 'click',
            topPos: '30px',
            fixedPosition: false,
        });
    });
}

function sorted_filtered_keys(obj) {
    var keys = [];

    for(var key in obj) {
        if (key.charAt(0) != '_') { // ignore _keys: NOTE that these may have NULL values.
            keys.push(key);
        }
    }

    keys.sort();
    return keys;
}

function get_keys_with_duplicate_keyname(info) {
    var duplicate_keys = [];
    var key_dict = {}; 
    var keys = sorted_filtered_keys(info);
    
    for (var i=0; i < keys.length; i++) {
        xpaths = keys[i].split('/');
        key_name = xpaths[xpaths.length-1];    // just use the last part of the xpath instead of the whole xpath
        if (key_name.length > 0 && key_name[0] == '@') {
            key_name = key_name.slice(1, key_name.length);
        }
        for(var prev_key in key_dict) {
            if (key_dict[prev_key] == key_name) {
                duplicate_keys.push(prev_key);
                duplicate_keys.push(keys[i]);
                break;
            }
        }
        key_dict[keys[i]] = key_name;
    }
    return duplicate_keys;
}

function contains(arr, obj) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] === obj) {
            return true;
        }
    }
    return false;
}

function set_info(div, info) {
    var rows = "";
    var row;
    var xpaths;
    var x_last;
    var key;

    var keys = sorted_filtered_keys(info);
    var duplicate_keys = get_keys_with_duplicate_keyname(info);

    for (var i=0; i < keys.length; i++) {
        key = keys[i];
        xpaths = key.split('/');
        var is_contain = contains(duplicate_keys, key);
        if (is_contain == true && xpaths.length > 2) {   
            x_last = xpaths[xpaths.length-2] + "/" + xpaths[xpaths.length-1]; 
        }
        else {
            x_last = xpaths[xpaths.length-1];    // just use the last part of the xpath instead of the whole xpath
        }

        if (x_last.length > 0 && x_last[0] == '@') {
            x_last = x_last.slice(1, x_last.length);
        }

        // Note: title enables a mouseover tooltip
        row = "<span title=\"" + key + "\">" + x_last + "</span>"; // tooltip for key is the full xpath

        displayable_value = info[key].replace('&', '&amp;');       // tooltip for the value is the raw data showing entity codes.
        row += "<span title=\"" + displayable_value + "\">:  <b>" + info[key] + "</b></span>"; 
        rows = rows + row + "<br />\n";
    }

    div.innerHTML=rows;
}


function win_height() {
    if (window.innerWidth && window.innerHeight) {  // ie9 and firefox, etc
        return window.innerHeight;
        // width = window.innerWidth;
    }

    // ie standards mode (< ie9)
    if (document.compatMode=='CSS1Compat' && document.documentElement && document.documentElement.offsetWidth ) {
        return document.documentElement.offsetHeight;
        //width = document.documentElement.offsetWidth;
    }

    // ie backwards compatability mode (< ie9)
    if (document.body && document.body.offsetWidth) {
        return document.body.offsetHeight;
        //width = document.body.offsetWidth;
    }

    return 860; // a default height (for big screens)
}

function draw_and_resize_page_image(img_id, img_href) {
    var img_margin = 100; // this is an estimate of the size of the gubbins above the image (plus a little).
    var page_image = document.getElementById(img_id);
    page_image.src = img_href;

    page_image.onload = function()
    {
        img_width = page_image.width;
        img_height = page_image.height;

        new_height = win_height() - img_margin;
        scale = new_height/img_height;

        page_image.height = img_height * scale;
        page_image.width = img_width * scale;
    };
}

{% endblock %}

{% block onload %}
    var page_info = {{ page_info|safe }};
    draw_and_resize_page_image("page_img", "{{STATIC_URL}}" + page_info._img_url);

    set_tabs();    // Note: have to do this AFTER inserting text to get right sizes.

{% endblock %}

{% block paging %}
<!-- accesskey = shift plus alt plus N in firefox; just alt+N in iE -->
<span style="padding-left:17px;">
    <a href="{% url page prev_page.id %}" accesskey="p" style="background: black; color: white; padding: 0px 7px 0px 7px;"><u>p</u>rev</a>
    <a href="{% url page next_page.id %}" accesskey="n" style="background: black; color: white; padding: 0px 7px 0px 7px;"><u>n</u>ext</a>
</span>
<span style="padding: 0px 0px 0px 10px;">
{% for p in pages %}
    {% if p.id == page.id %}
        <span style="background: black; border:7px; color: white; padding:0px 1px 0px 1px;">
        {{ forloop.counter|add:pager_start_i }}
        </span>
    {% else %}
        <span style="background: white; border:1px; color: black; padding:0px 1px 0px 1px;">
        <a href="{% url page p.id %}">{{ forloop.counter|add:pager_start_i }}</a>
        </span>
    {% endif %}
{% endfor %}
</span>
{% endblock %}

{% block content %}
<h1>page {{ page.dom_name }} <small>(<a href="{% url item item_index.id %}">{{item_index.dom_name}}</a>)</small></h1>
<img id="page_img" src="" alt="page image"/>



<div class="fix_tab">
    <a class="handle1" href="http://link-for-non-js-users">Please enable Javascript</a>
    <div style="width:100%; height:780px; overflow: auto;" >
    {{ fix_form_html|safe }}
    </div>
</div>


<div class="reject_tab">
    <a class="handle2" href="http://link-for-non-js-users">Please enable Javascript</a>
    <form action="{% url reject item_index.id page.id %}" method="post" id="reject_reason">

        <input type="hidden" size="0%" name="current_page" value="{{ request.get_full_path }}">

        <p>please enter a reason for rejecting this item:</p>
        <p>{{ reject_form.reason }}</p>

        <ul>
            <li>you can use &apos;save&apos; multiple times - but only 2000 characters are avail. in total</li>
            <li>pressing &apos;ftp&apos;:
                <ul>
                <li>will send what you saved + the original xml (with fixes if avail.) to the content provider</li>
                <li>will create a Rejected Item report</li>
                <li>might take a few minutes to complete</li>
                </ul>
            </li>
        </ul>

        <table width="100%">
            <tr>
                <td align="center"><input style="padding:7px; margin:3px; background-color: black; color: white; font-size:small" type="submit" name="save" value="save" /></td>
                <td align="center"><input style="padding:7px; margin:3px; background-color: black; color: white; font-size:small" type="submit" name="reject" value="ftp" /></td>
            </tr>
        </table>

    </form>
</div>

{% endblock %}
